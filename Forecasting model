# Import necessary libraries 

import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
from prophet import Prophet
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error
import warnings

warnings.filterwarnings("ignore")

# -------------------------------
# 1. Load and Prepare Data
# -------------------------------

df = pd.concat([df0,df1,df2], ignore_index=True)
#Drop the duplicates 
#Remove AEs except for Med devices
# Assign priority
def assign_priority(seriousness):
    if seriousness in ["Serious", "Priority"]:
        return 1
    elif seriousness in ["Non-Priority", "Non-Serious"]:
        return 2
    elif seriousness in ["Lack of Effect"]:
        return 3
    elif seriousness in [ "Adverse Event", "AE Level 1", "AE Level 2", "AE Level 3", "Serious AE"]:
        return 4
    elif seriousness == "Preference":
        return 5
    return None

df['Priority'] = df['seriousness'].apply(assign_priority)
df = df.sort_values(by=['tracking_no_link', 'Priority']).drop_duplicates('tracking_no_link', keep='first')

# Enterprise classification
def processed_data(df):
    df['Enterprise'] = np.where(
        df['seriousness'].isin(['Adverse Event', 'AE Level 1', 'AE Level 2', 'AE Level 3', 'Serious AE']),
        'Adverse Event',
        np.where(
            df['seriousness'].isin(['Non-Serious', 'Serious', 'Lack of Effect', 'Priority', 'Non-Priority']),
            'PQC',
            np.where(df['seriousness'] == 'Preference', 'Preference', np.nan)
        )
    )
    return df[~((df['Enterprise'] == 'Adverse Event') & (~df['reg_class'].isin(['MEDICAL DEVICE', 'MEDICAL DEVICE II'])))]

df = processed_data(df)
df = df.drop_duplicates(subset='tracking_no_link', keep='first')
df= df.drop(columns=['translate_rptr','prog_event_txt', 'region'])
company_to_region = {
    'APAC':'APAC',
    'EMEA':'EMEA',
    'LATAM':'LATAM',
    'North America Consumer': 'NA',
    'North America Drug': 'NA',
    'NUTRITIONALS':'NA'
}
df['region'] =  df['company'].map(company_to_region)

df['region'] = df['region'].fillna('NA')
df['iss_entrd_pqms'] = pd.to_datetime(df['iss_entrd_pqms'], errors='coerce')
df['Month'] = df['iss_entrd_pqms'].dt.to_period('M').dt.to_timestamp()
df['Complaint Count'] = 1
#df = df.dropna(subset=['iss_entrd_pqms', 'region'])

df['Month'] = pd.to_datetime(df['iss_entrd_pqms']).dt.to_period('M').dt.to_timestamp()

# Add global
global_df = df.groupby('Month', as_index=False)['Complaint Count'].sum()
global_df['region'] = 'Global'
df = pd.concat([df, global_df], ignore_index=True)

# -----------------------------
# 2. Forecasting Function
# -----------------------------
def evaluate_models(monthly_df):
    monthly_df = monthly_df.set_index('Month').resample('M').sum()
    y = monthly_df['Complaint Count'].dropna()

    if len(y) < 12 or y.nunique() < 2:
        return None

    models = {}

    # Prophet
    try:
        prophet_df = y.reset_index().rename(columns={'Month': 'ds', 'Complaint Count': 'y'})
        model = Prophet(yearly_seasonality='auto', changepoint_prior_scale=0.1)
        model.fit(prophet_df)
        future = model.make_future_dataframe(periods=12, freq='M')
        forecast = model.predict(future)
        forecast['yhat'] = forecast['yhat'].round(0)
        forecast['yhat_lower'] = forecast['yhat_lower'].round(0)
        forecast['yhat_upper'] = forecast['yhat_upper'].round(0)

        fitted = forecast['yhat'][:len(y)].values
        resid = y.values - fitted
        rmse = np.sqrt(mean_squared_error(y, fitted))
        models['Prophet'] = (rmse, forecast.tail(12), y, fitted, resid, forecast)
    except Exception as e:
        print(f"Prophet failed: {e}")

    # Holt-Winters
    try:
        hw = ExponentialSmoothing(y, seasonal='add', seasonal_periods=12).fit()
        fitted = hw.fittedvalues
        forecast_vals = hw.forecast(12).round(0)
        resid = y.values - fitted
        rmse = np.sqrt(mean_squared_error(y, fitted))
        models['Holt-Winters'] = (rmse, forecast_vals, y, fitted, resid, None)
    except Exception as e:
        print(f"Holt-Winters failed: {e}")

    # ARIMA
    try:
        arima = ARIMA(y, order=(1, 1, 1)).fit()
        fitted = arima.predict(start=1, end=len(y), typ='levels')
        forecast_vals = arima.forecast(12).round(0)
        resid = y[1:].values - fitted
        rmse = np.sqrt(mean_squared_error(y[1:], fitted))
        models['ARIMA'] = (rmse, forecast_vals, y[1:], fitted, resid, None)
    except Exception as e:
        print(f"ARIMA failed: {e}")

    if not models:
        return None

    best_model = min(models.items(), key=lambda x: x[1][0])
    return best_model[0], best_model[1]

# -----------------------------
# 3. Run Forecasts Per Region
# -----------------------------
output_dir = "region_forecasts"
os.makedirs(output_dir, exist_ok=True)
summary = []

for region in df['region'].unique():
    print(f"\nProcessing: {region}")
    region_df = df[df['region'] == region]
    monthly_df = region_df.groupby('Month', as_index=False)['Complaint Count'].sum()

    result = evaluate_models(monthly_df)
    if result is None:
        continue

    best_model_name, (rmse, forecast, y_true, fitted, resid, full_forecast) = result
    rmse_percent =(rmse/y_true.mean())*100
    if rmse_percent < 10:
        print('RMSE is less than 10% of the average actual complaints.')
    else:
        print('RMSE ids greater than or equal to 10%')
    # Prepare forecast DataFrame
    if isinstance(forecast, pd.DataFrame):
        forecast_df = forecast.rename(columns={
            'ds': 'Month',
            'yhat': 'Predicted Complaints',
            'yhat_lower': 'Lower Bound',
            'yhat_upper': 'Upper Bound'
        })[['Month', 'Predicted Complaints', 'Lower Bound', 'Upper Bound']]
    else:
        forecast_df = pd.DataFrame({
            'Month': pd.date_range(start=monthly_df['Month'].max() + pd.offsets.MonthBegin(), periods=12, freq='M'),
            'Predicted Complaints': forecast.values
        })

    forecast_path = os.path.join(output_dir, f"{region}_forecast.xlsx")
    forecast_df.to_excel(forecast_path, index=False)

    # Plot Forecast and Residuals
    plt.figure(figsize=(14, 6))

    # Forecast Plot
    plt.subplot(1, 2, 1)
    plt.plot(y_true.index, y_true.values, label='Actual', color='black', linestyle='dashed')
    plt.plot(y_true.index, fitted, label='Fitted', linewidth=2)
    if full_forecast is not None:
        plt.fill_between(full_forecast['ds'], full_forecast['yhat_lower'], full_forecast['yhat_upper'],
                         color='skyblue', alpha=0.4, label='Confidence Interval')
        plt.plot(full_forecast['ds'], full_forecast['yhat'], label='Forecast', color='blue')
    plt.title(f"{region} - {best_model_name} Forecast")
    plt.xlabel("Month")
    plt.ylabel("Complaints")
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.legend()

    # Residual Plot
    plt.subplot(1, 2, 2)
    plt.plot(y_true.index, resid, marker='o', linestyle='-')
    plt.axhline(0, color='red', linestyle='--')
    plt.title(f"{region} - Residuals")
    plt.xticks(rotation=45)
    plt.grid(True)

    plt.tight_layout()
    plot_path = os.path.join(output_dir, f"{region}_{best_model_name}_plot.png")
    plt.savefig(plot_path)
    plt.close()

    summary.append({
        'Region': region,
        'Best Model': best_model_name,
        'RMSE': round(rmse, 2),
        'RMSE of % mean': round(rmse_percent,2),
        'Forecast File': forecast_path,
        'Plot File': plot_path
    })

# -----------------------------
# 4. Save Summary Report
# -----------------------------
summary_df = pd.DataFrame(summary)
summary_df.to_excel(os.path.join(output_dir, "forecast_summary.xlsx"), index=False)

print("\nForecasting complete. All outputs saved in:", output_dir)
